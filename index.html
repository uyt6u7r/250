<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sevens & Melds</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import Map for Gemini SDK -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>

    <style>
        .pattern-grid {
            background-color: #1e3a8a;
            background-image: radial-gradient(#3b82f6 1px, transparent 1px);
            background-size: 10px 10px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2); 
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4); 
        }
    </style>
</head>
<body class="bg-green-800 text-white font-sans select-none overflow-hidden fixed inset-0">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import { GoogleGenAI } from "@google/genai";

        // --- CONSTANTS & TYPES ---
        
        const Suit = {
            HEARTS: '♥',
            DIAMONDS: '♦',
            CLUBS: '♣',
            SPADES: '♠',
            JOKER: '★'
        };

        const Rank = {
            ACE: 'A',
            TWO: '2',
            THREE: '3',
            FOUR: '4',
            FIVE: '5',
            SIX: '6',
            SEVEN: '7',
            EIGHT: '8',
            NINE: '9',
            TEN: '10',
            JACK: 'J',
            QUEEN: 'Q',
            KING: 'K',
            JOKER: 'JOKER'
        };

        // UI Constants - Increased for visibility
        const CARD_WIDTH = "w-24 sm:w-28 md:w-32";
        const CARD_HEIGHT = "h-36 sm:h-40 md:h-48";
        const MAX_SCORE = 250;

        const SUITS = [Suit.HEARTS, Suit.DIAMONDS, Suit.CLUBS, Suit.SPADES];
        const RANKS = [
            Rank.ACE, Rank.TWO, Rank.THREE, Rank.FOUR, Rank.FIVE, Rank.SIX,
            Rank.SEVEN, Rank.EIGHT, Rank.NINE, Rank.TEN, Rank.JACK, Rank.QUEEN, Rank.KING
        ];

        const getSortValue = (rank) => {
            if (rank === Rank.JOKER) return 99;
            const index = RANKS.indexOf(rank);
            return index + 1;
        };

        const getPoints = (rank) => {
            if (rank === Rank.JOKER) return 30;
            if (rank === Rank.SEVEN) return 15;
            if ([Rank.JACK, Rank.QUEEN, Rank.KING].includes(rank)) return 10;
            if (rank === Rank.ACE) return 1;
            return parseInt(rank);
        };

        // --- GAME LOGIC ---

        const createDeck = (playerCount) => {
            const numDecks = playerCount >= 4 ? 2 : 1;
            let deck = [];

            for (let d = 0; d < numDecks; d++) {
                SUITS.forEach(suit => {
                    if (suit === Suit.JOKER) return;
                    RANKS.forEach(rank => {
                        deck.push({
                            id: `${suit}-${rank}-${d}-${Math.random().toString(36).substr(2, 9)}`,
                            suit,
                            rank,
                            value: getPoints(rank),
                            sortValue: getSortValue(rank),
                            isJoker: false
                        });
                    });
                });

                deck.push({ id: `JOKER-1-${d}-${Math.random()}`, suit: Suit.JOKER, rank: Rank.JOKER, value: 30, sortValue: 99, isJoker: true });
                deck.push({ id: `JOKER-2-${d}-${Math.random()}`, suit: Suit.JOKER, rank: Rank.JOKER, value: 30, sortValue: 99, isJoker: true });
            }

            return shuffle(deck);
        };

        const shuffle = (array) => {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        };

        const canPlayOnBoard = (card, sequences) => {
            if (card.isJoker) return true;
            if (card.rank === Rank.SEVEN) return !sequences[card.suit].hasSeven;

            const seq = sequences[card.suit];
            if (!seq.hasSeven) return false;

            const val = card.sortValue;
            return val === seq.high + 1 || val === seq.low - 1;
        };

        const calculateHandPoints = (hand) => {
            return hand.reduce((sum, card) => sum + card.value, 0);
        };

        const applyFinalScores = (players, knockerIndex, jokerDeclarations) => {
            const roundScores = players.map(p => {
                let pts = calculateHandPoints(p.hand);
                p.hand.forEach(card => {
                    if (!card.isJoker) {
                        const isDeclared = jokerDeclarations.some(decl => 
                            decl.representedRank === card.rank && decl.representedSuit === card.suit
                        );
                        if (isDeclared) pts += 30;
                    }
                });
                return pts;
            });

            const knockerScore = roundScores[knockerIndex];
            let undercut = false;
            
            players.forEach((p, i) => {
                if (i !== knockerIndex && roundScores[i] <= knockerScore) undercut = true;
            });

            const newPlayers = players.map(p => ({ ...p }));

            if (undercut) {
                const totalPoints = roundScores.reduce((a, b) => a + b, 0);
                newPlayers[knockerIndex].score += totalPoints;
            } else {
                newPlayers.forEach((p, i) => {
                    p.score += roundScores[i];
                });
            }

            return newPlayers;
        };

        const setupTutorialGame = () => {
            const mkCard = (suit, rank, isJoker = false) => ({
                id: `tut-${suit}-${rank}-${Math.random()}`,
                suit,
                rank,
                value: getPoints(rank),
                sortValue: getSortValue(rank),
                isJoker
            });

            const humanHand = [
                mkCard(Suit.HEARTS, Rank.SEVEN),
                mkCard(Suit.HEARTS, Rank.EIGHT),
                mkCard(Suit.CLUBS, Rank.TWO),
                mkCard(Suit.CLUBS, Rank.TWO),
                mkCard(Suit.JOKER, Rank.JOKER, true),
                mkCard(Suit.DIAMONDS, Rank.KING),
                mkCard(Suit.SPADES, Rank.THREE),
            ].sort((a, b) => a.sortValue - b.sortValue);

            const botHand = [
                mkCard(Suit.CLUBS, Rank.TWO), 
                mkCard(Suit.SPADES, Rank.TEN),
                mkCard(Suit.DIAMONDS, Rank.FIVE),
                mkCard(Suit.HEARTS, Rank.ACE),
                mkCard(Suit.CLUBS, Rank.NINE),
                mkCard(Suit.SPADES, Rank.KING),
                mkCard(Suit.DIAMONDS, Rank.FOUR),
            ];

            const deck = [
                mkCard(Suit.HEARTS, Rank.ACE),
                mkCard(Suit.SPADES, Rank.ACE),
                ...createDeck(2)
            ];

            const players = [
                { id: 0, name: "You (Student)", isHuman: true, hand: humanHand, score: 0, hasKnocked: false, melds: [] },
                { id: 1, name: "Sensei Bot", isHuman: false, hand: botHand, score: 0, hasKnocked: false, melds: [] }
            ];

            const initialSequences = {
                [Suit.HEARTS]: { suit: Suit.HEARTS, low: 7, high: 7, hasSeven: false },
                [Suit.DIAMONDS]: { suit: Suit.DIAMONDS, low: 7, high: 7, hasSeven: false },
                [Suit.CLUBS]: { suit: Suit.CLUBS, low: 7, high: 7, hasSeven: false },
                [Suit.SPADES]: { suit: Suit.SPADES, low: 7, high: 7, hasSeven: false },
                [Suit.JOKER]: { suit: Suit.JOKER, low: 0, high: 0, hasSeven: false }
            };

            return {
                players,
                currentPlayerIndex: 0,
                deck,
                discardPile: [],
                boardSequences: initialSequences,
                turnPhase: 'ACTION',
                round: 1,
                winner: null,
                logs: ["Tutorial Started! Follow the instructions."],
                pendingPong: null,
                jokerDeclarations: [],
                isTutorial: true,
                tutorialStep: 0
            };
        };

        const TUTORIAL_STEPS = [
            {
                title: "Rule 1: The Sevens",
                text: "Welcome! In this game, 7s are special. They start the board sequences. You have a Heart 7. Click it to select, then click 'Play' to place it in the center.",
                action: "PLAY_7"
            },
            {
                title: "Rule 2: Sequences",
                text: "Now that the Heart 7 is out, you can play a 6 or 8 of the same suit. Select your Heart 8 and play it.",
                action: "PLAY_8"
            },
            {
                title: "Rule 3: Drawing",
                text: "Normally you would try to play more, but let's say you're stuck or saving cards. Click 'Draw Card' to take one from the deck.",
                action: "DRAW"
            },
            {
                title: "Rule 4: Discarding",
                text: "Your turn ends by discarding. High value cards (Face cards=10, Jokers=30) are bad for your score. Discard that Diamond King!",
                action: "DISCARD_K"
            },
            {
                title: "Opponent Turn",
                text: "The Bot is playing... wait for it.",
                action: "WAIT"
            },
            {
                title: "Rule 5: Pong!",
                text: "The Bot discarded a Club 2. You have two Club 2s in hand! This is a 'Pong'. You can take the discard to form a set (Meld) of 3. Click 'PONG!'.",
                action: "PONG"
            },
            {
                title: "Rule 6: Jokers",
                text: "Jokers are Wild but worth 30 points if left in hand! You must declare what card they represent. Play your Joker now - the game will ask you to assign it to the Heart sequence (e.g., as Heart 9).",
                action: "PLAY_JOKER"
            },
            {
                title: "Rule 7: Knocking",
                text: "Your hand points are now very low (<= 5). This allows you to KNOCK. Knocking ends the round immediately. Click 'KNOCK' to win this tutorial!",
                action: "KNOCK"
            }
        ];

        // --- COMPONENTS ---

        const Card = ({ card, onClick, isSelected, isPlayable, className, hidden }) => {
            const isRed = card.suit === Suit.HEARTS || card.suit === Suit.DIAMONDS;
            // Updated Sizes and Fonts
            const baseClasses = `${CARD_WIDTH} ${CARD_HEIGHT} rounded-xl shadow-md border-2 relative flex flex-col justify-between p-2 sm:p-3 transition-all duration-200 select-none`;
            const colorClasses = isRed ? "text-red-600 border-gray-300 bg-white" : "text-black border-gray-300 bg-white";
            const stateClasses = isSelected ? "-translate-y-8 ring-4 ring-yellow-400 z-10" : "hover:-translate-y-4";
            const bgClass = hidden ? "bg-blue-700 pattern-grid" : "";

            if (hidden) {
                return (
                    <div className={`${baseClasses} ${bgClass} ${className || ''}`}>
                        <div className="w-full h-full rounded border border-blue-500 bg-blue-800 flex items-center justify-center">
                            <span className="text-white opacity-20 text-5xl">♠</span>
                        </div>
                    </div>
                );
            }

            return (
                <div 
                    onClick={onClick}
                    className={`${baseClasses} ${colorClasses} ${stateClasses} ${bgClass} ${className || ''} ${isPlayable ? 'cursor-pointer' : 'cursor-default opacity-90'}`}
                >
                    {/* Corner Value - Larger Text */}
                    <div className="text-xl sm:text-2xl md:text-3xl font-bold leading-none">
                        <div>{card.rank}</div>
                        <div>{card.suit}</div>
                    </div>
                    {/* Center Watermark - Larger */}
                    <div className="absolute inset-0 flex items-center justify-center text-6xl sm:text-7xl md:text-8xl opacity-10 pointer-events-none">{card.suit}</div>
                    {/* Bottom Corner - Larger Text */}
                    <div className="text-xl sm:text-2xl md:text-3xl font-bold leading-none self-end rotate-180">
                        <div>{card.rank}</div>
                        <div>{card.suit}</div>
                    </div>
                </div>
            );
        };

        const createVisualCard = (suit, val) => {
            if (val < 1 || val > 13) return null;
            const rank = RANKS[val - 1];
            return {
                id: `visual-${suit}-${rank}`,
                suit,
                rank,
                value: 0,
                sortValue: val,
                isJoker: false
            };
        };

        const Board = ({ sequences }) => {
            return (
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-6 w-full max-w-7xl mx-auto px-4">
                    {SUITS.filter(s => s !== Suit.JOKER).map(suit => {
                        const seq = sequences[suit];
                        const lowCard = seq.hasSeven ? createVisualCard(suit, seq.low) : null;
                        const highCard = seq.hasSeven ? createVisualCard(suit, seq.high) : null;

                        return (
                            <div key={suit} className="flex flex-col items-center min-h-[300px] justify-start bg-white/5 rounded-2xl p-4 border border-white/10 shadow-lg">
                                {!seq.hasSeven && (
                                    <div className="border-4 border-dashed border-white/20 w-full h-48 rounded-2xl flex items-center justify-center mt-8">
                                        <span className="text-6xl text-white/20">{suit}</span>
                                        <span className="text-sm text-white/50 absolute bottom-4 uppercase font-bold tracking-widest">Waiting for 7</span>
                                    </div>
                                )}
                                {seq.hasSeven && (
                                    <div className="flex flex-col items-center w-full space-y-2">
                                        {/* High Card */}
                                        <div className="relative z-0">
                                            {highCard && highCard.rank !== Rank.SEVEN ? (
                                                <div className="relative group">
                                                    <span className="absolute -left-8 top-1/2 -translate-y-1/2 text-xs text-white/70 rotate-[-90deg] font-bold tracking-widest">MAX</span>
                                                    <Card card={highCard} className="scale-90 opacity-80 group-hover:opacity-100 group-hover:scale-95" />
                                                </div>
                                            ) : <div className="h-8"></div>}
                                        </div>
                                        {/* Seven */}
                                        <div className="relative z-10 shadow-2xl ring-4 ring-yellow-500/50 rounded-xl my-2">
                                            <Card card={createVisualCard(suit, 7)} />
                                        </div>
                                        {/* Low Card */}
                                        <div className="relative z-0">
                                            {lowCard && lowCard.rank !== Rank.SEVEN ? (
                                                <div className="relative group">
                                                     <span className="absolute -left-8 top-1/2 -translate-y-1/2 text-xs text-white/70 rotate-[-90deg] font-bold tracking-widest">MIN</span>
                                                    <Card card={lowCard} className="scale-90 opacity-80 group-hover:opacity-100 group-hover:scale-95" />
                                                </div>
                                            ) : <div className="h-8"></div>}
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            );
        };

        const Modal = ({ children, onClose, title }) => (
            <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-[100] animate-fade-in p-4">
                <div className="bg-white p-6 rounded-2xl shadow-2xl max-w-md w-full relative flex flex-col max-h-[90vh]">
                    {onClose && <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-black text-2xl font-bold leading-none">&times;</button>}
                    {title && <h2 className="text-2xl font-bold mb-4 text-center border-b pb-3 text-gray-800">{title}</h2>}
                    <div className="flex-1 overflow-y-auto text-gray-800 p-1">
                        {children}
                    </div>
                </div>
            </div>
        );

        // --- APP COMPONENT ---

        const App = () => {
            const [gameState, setGameState] = React.useState(null);
            const [selectedCards, setSelectedCards] = React.useState([]);
            const [showPongModal, setShowPongModal] = React.useState(false);
            const [pongTimer, setPongTimer] = React.useState(10);
            
            const [showSingleJokerModal, setShowSingleJokerModal] = React.useState(false);
            const [pendingSingleJokerMove, setPendingSingleJokerMove] = React.useState(null);
            
            // New state for declaring jokers in melds
            const [pendingMeldAction, setPendingMeldAction] = React.useState(null);
            const [meldDeclarations, setMeldDeclarations] = React.useState({});
            
            const [roundSummary, setRoundSummary] = React.useState(null);
            const [aiHint, setAiHint] = React.useState(null);
            const [isLoadingHint, setIsLoadingHint] = React.useState(false);
            const [gameStarted, setGameStarted] = React.useState(false);
            const [playerCount, setPlayerCount] = React.useState(4);
            const [apiKey, setApiKey] = React.useState('');
            const [showKeyInput, setShowKeyInput] = React.useState(false);

            // --- API Logic ---
            const getAIHint = async (state) => {
                if (!apiKey) return "Please set your Gemini API Key in the main menu to use hints.";
                setIsLoadingHint(true);
                const client = new GoogleGenAI({ apiKey });
                
                const player = state.players[0];
                const handStr = player.hand.map(c => `${c.rank}${c.suit}`).join(', ');
                const boardStr = Object.entries(state.boardSequences)
                    .filter(([_, seq]) => seq.hasSeven)
                    .map(([suit, seq]) => `${suit}: ${seq.low}-${seq.high}`)
                    .join(' | ');

                const prompt = `
                    You are an expert card game strategist for 'Sevens & Melds'.
                    Goal: Lowest score. Knock when hand <= 5.
                    Hand: ${handStr}.
                    Board: ${boardStr || "Empty"}.
                    My Score: ${player.hand.reduce((acc, c) => acc + c.value, 0)}.
                    Suggest the best move concisely.
                `;

                try {
                    const response = await client.models.generateContent({
                        model: 'gemini-2.5-flash',
                        contents: prompt,
                    });
                    setAiHint(response.text || "No hint generated.");
                } catch (e) {
                    console.error(e);
                    setAiHint("Error connecting to AI. Check API Key.");
                } finally {
                    setIsLoadingHint(false);
                }
            };

            // --- Game Actions ---
            const startGame = () => {
                const deck = createDeck(playerCount);
                const players = Array.from({ length: playerCount }).map((_, i) => ({
                    id: i,
                    name: i === 0 ? "You" : `Bot ${i}`,
                    isHuman: i === 0,
                    hand: [],
                    score: 0,
                    hasKnocked: false,
                    melds: []
                }));

                players.forEach(p => {
                    p.hand = deck.splice(0, 7).sort((a, b) => a.sortValue - b.sortValue);
                });

                const initialSequences = {
                    [Suit.HEARTS]: { suit: Suit.HEARTS, low: 7, high: 7, hasSeven: false },
                    [Suit.DIAMONDS]: { suit: Suit.DIAMONDS, low: 7, high: 7, hasSeven: false },
                    [Suit.CLUBS]: { suit: Suit.CLUBS, low: 7, high: 7, hasSeven: false },
                    [Suit.SPADES]: { suit: Suit.SPADES, low: 7, high: 7, hasSeven: false },
                    [Suit.JOKER]: { suit: Suit.JOKER, low: 0, high: 0, hasSeven: false }
                };

                setGameState({
                    players,
                    currentPlayerIndex: 0,
                    deck,
                    discardPile: [],
                    boardSequences: initialSequences,
                    turnPhase: 'ACTION',
                    round: 1,
                    winner: null,
                    logs: ["Game started!"],
                    pendingPong: null,
                    jokerDeclarations: []
                });
                setGameStarted(true);
                setAiHint(null);
                setRoundSummary(null);
            };

            const startTutorial = () => {
                setGameState(setupTutorialGame());
                setGameStarted(true);
                setAiHint(null);
                setRoundSummary(null);
            };

            const addLog = (msg) => {
                setGameState(prev => prev ? ({ ...prev, logs: [msg, ...prev.logs.slice(0, 4)] }) : null); // Prepend logs
            };

            const handleCardClick = (card) => {
                if (!gameState || (gameState.turnPhase !== 'ACTION' && gameState.turnPhase !== 'DISCARD')) return;
                if (gameState.currentPlayerIndex !== 0) return;

                if (selectedCards.includes(card.id)) {
                    setSelectedCards(prev => prev.filter(id => id !== card.id));
                } else {
                    if (gameState.turnPhase === 'DISCARD') {
                        setSelectedCards([card.id]);
                    } else {
                        setSelectedCards(prev => [...prev, card.id]);
                    }
                }
            };

            const playSelectedCards = () => {
                if (!gameState || selectedCards.length === 0) return;

                // Tutorial Interception
                if (gameState.isTutorial) {
                    const step = TUTORIAL_STEPS[gameState.tutorialStep || 0];
                    const card = gameState.players[0].hand.find(c => c.id === selectedCards[0]);
                    if (!card) return;

                    if (step.action === "PLAY_7" && (card.rank !== Rank.SEVEN || card.suit !== Suit.HEARTS)) { addLog("Tutorial: Play Heart 7."); return; }
                    if (step.action === "PLAY_8" && (card.rank !== Rank.EIGHT || card.suit !== Suit.HEARTS)) { addLog("Tutorial: Play Heart 8."); return; }
                    if (step.action === "PLAY_JOKER" && !card.isJoker) { addLog("Tutorial: Play Joker."); return; }
                }

                const player = gameState.players[0];
                const cardsToPlay = player.hand.filter(c => selectedCards.includes(c.id));

                if (cardsToPlay.length === 1) {
                    const card = cardsToPlay[0];
                    if (card.isJoker) {
                        const playableSuits = SUITS.filter(s => s !== Suit.JOKER && gameState.boardSequences[s].hasSeven);
                        if (playableSuits.length === 0) {
                            addLog("Joker cannot be 7.");
                            return;
                        }
                        setPendingSingleJokerMove({ card, context: 'SEQUENCE' }); 
                        setShowSingleJokerModal(true);
                        return;
                    }

                    let valid = false;
                    let newSequences = { ...gameState.boardSequences };

                    if (card.rank === Rank.SEVEN && !newSequences[card.suit].hasSeven) {
                        newSequences[card.suit].hasSeven = true;
                        valid = true;
                    } else if (canPlayOnBoard(card, newSequences)) {
                        const seq = newSequences[card.suit];
                        if (card.sortValue === seq.high + 1) seq.high = card.sortValue;
                        if (card.sortValue === seq.low - 1) seq.low = card.sortValue;
                        valid = true;
                    }

                    if (valid) {
                        const newHand = player.hand.filter(c => c.id !== card.id);
                        const nextStep = gameState.isTutorial ? (gameState.tutorialStep || 0) + 1 : gameState.tutorialStep;
                        setGameState({
                            ...gameState,
                            players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand } : p),
                            boardSequences: newSequences,
                            logs: [`You played ${card.rank} ${card.suit}`, ...gameState.logs],
                            tutorialStep: nextStep
                        });
                        setSelectedCards([]);
                    } else {
                        addLog("Invalid move!");
                    }
                } else if (cardsToPlay.length === 3) {
                     if (gameState.isTutorial) { addLog("Tutorial: Singles only now."); return; }
                     const jokers = cardsToPlay.filter(c => c.isJoker);
                     const nonJokers = cardsToPlay.filter(c => !c.isJoker);
                     
                     if (nonJokers.length > 0) {
                         const targetRank = nonJokers[0].rank;
                         if (!nonJokers.every(c => c.rank === targetRank)) { addLog("Ranks match failed."); return; }
                         if (targetRank === Rank.SEVEN && jokers.length > 0) { addLog("No Joker on 7s."); return; }
                         
                         if (jokers.length > 0) {
                             setMeldDeclarations({});
                             setPendingMeldAction({ type: 'MELD', cards: cardsToPlay, naturalRank: targetRank, jokersCount: jokers.length });
                             return;
                         }
                         // Clean meld
                         const newHand = player.hand.filter(c => !selectedCards.includes(c.id));
                         setGameState({
                             ...gameState,
                             players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand, melds: [...p.melds, cardsToPlay] } : p),
                             logs: [`Melded three ${targetRank}s`, ...gameState.logs]
                         });
                         setSelectedCards([]);
                     } else {
                         // 3 Jokers
                         setMeldDeclarations({});
                         setPendingMeldAction({ type: 'MELD', cards: cardsToPlay, naturalRank: null, jokersCount: 3 });
                     }
                }
            };

            const confirmSingleJokerMove = (declaredSuit, declaredRank) => {
                if (!gameState || !pendingSingleJokerMove) return;
                const { card } = pendingSingleJokerMove;
                if (declaredRank === Rank.SEVEN) return;

                let newSequences = { ...gameState.boardSequences };
                const seq = newSequences[declaredSuit];
                const val = getSortValue(declaredRank);
                if (val === seq.high + 1) seq.high = val;
                if (val === seq.low - 1) seq.low = val;

                const newHand = gameState.players[0].hand.filter(c => c.id !== card.id);
                const nextStep = gameState.isTutorial ? (gameState.tutorialStep || 0) + 1 : gameState.tutorialStep;
                
                setGameState({
                    ...gameState,
                    players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand } : p),
                    boardSequences: newSequences,
                    jokerDeclarations: [...gameState.jokerDeclarations, { cardId: card.id, representedSuit: declaredSuit, representedRank: declaredRank }],
                    logs: [`Joker played as ${declaredRank} ${declaredSuit}`, ...gameState.logs],
                    tutorialStep: nextStep
                });
                setShowSingleJokerModal(false);
                setPendingSingleJokerMove(null);
                setSelectedCards([]);
            };

            const confirmMeldWithJokers = () => {
                 if (!gameState || !pendingMeldAction) return;
                 const { type, cards, naturalRank } = pendingMeldAction;
                 const player = gameState.players[0];
                 const jokersInMeld = cards.filter(c => c.isJoker);
                 
                 // Validate declarations
                 if (jokersInMeld.length > Object.keys(meldDeclarations).length) {
                     alert("Please declare all Jokers.");
                     return;
                 }
                 if (!naturalRank && !meldDeclarations['rank']) {
                     alert("Please select a Rank for the Joker Meld.");
                     return;
                 }

                 const finalRank = naturalRank || meldDeclarations['rank'];
                 
                 const newJokerDeclarations = jokersInMeld.map((joker, idx) => {
                     const decl = meldDeclarations[joker.id] || {};
                     return {
                         cardId: joker.id,
                         representedSuit: decl.suit || Suit.HEARTS, // Default fallback
                         representedRank: finalRank
                     };
                 });

                 let newHand = [], newDiscard = [...gameState.discardPile], nextPhase = gameState.turnPhase, pendingPong = gameState.pendingPong;

                 if (type === 'MELD') {
                     newHand = player.hand.filter(c => !cards.some(played => played.id === c.id));
                 } else { // PONG
                     newHand = player.hand.filter(c => !cards.some(played => played.id === c.id));
                     newDiscard = newDiscard.slice(1);
                     nextPhase = 'ACTION';
                     pendingPong = null;
                 }

                 setGameState({
                     ...gameState,
                     players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand, melds: [...p.melds, cards] } : p),
                     discardPile: newDiscard,
                     turnPhase: nextPhase,
                     currentPlayerIndex: 0,
                     pendingPong: pendingPong,
                     jokerDeclarations: [...gameState.jokerDeclarations, ...newJokerDeclarations]
                 });
                 setPendingMeldAction(null);
                 setMeldDeclarations({});
                 setSelectedCards([]);
                 setShowPongModal(false);
            };

            const drawCard = () => {
                if (!gameState || gameState.turnPhase !== 'ACTION') return;
                if (gameState.isTutorial && TUTORIAL_STEPS[gameState.tutorialStep].action !== "DRAW") { addLog("Tutorial: Don't draw yet."); return; }
                
                const deck = [...gameState.deck];
                if (deck.length === 0) {
                    setGameState({...gameState, turnPhase: 'DISCARD'});
                    return;
                }
                const card = deck.shift();
                const player = { ...gameState.players[0] };
                player.hand = [...player.hand, card].sort((a,b) => a.sortValue - b.sortValue);
                const nextStep = gameState.isTutorial ? (gameState.tutorialStep || 0) + 1 : gameState.tutorialStep;

                setGameState({
                    ...gameState,
                    deck,
                    players: gameState.players.map((p, i) => i === 0 ? player : p),
                    turnPhase: 'DISCARD',
                    logs: ["You drew a card.", ...gameState.logs],
                    tutorialStep: nextStep
                });
            };

            const discardCard = () => {
                if (!gameState || selectedCards.length !== 1 || gameState.turnPhase !== 'DISCARD') return;
                const card = gameState.players[0].hand.find(c => c.id === selectedCards[0]);
                if (gameState.isTutorial && TUTORIAL_STEPS[gameState.tutorialStep].action === "DISCARD_K" && card.rank !== Rank.KING) { addLog("Tutorial: Discard King."); return; }

                const newHand = gameState.players[0].hand.filter(c => c.id !== card.id);
                const nextStep = gameState.isTutorial ? (gameState.tutorialStep || 0) + 1 : gameState.tutorialStep;

                setGameState({
                    ...gameState,
                    players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand } : p),
                    discardPile: [card, ...gameState.discardPile],
                    currentPlayerIndex: (gameState.currentPlayerIndex + 1) % gameState.players.length,
                    turnPhase: 'ACTION',
                    logs: [`You discarded ${card.rank}`, ...gameState.logs],
                    pendingPong: { card, discarderIndex: 0 },
                    tutorialStep: nextStep
                });
                setSelectedCards([]);
            };

            const handleKnock = () => {
                if (!gameState) return;
                const points = calculateHandPoints(gameState.players[0].hand);
                if (gameState.isTutorial && TUTORIAL_STEPS[gameState.tutorialStep].action !== "KNOCK") { addLog("Tutorial: Wait."); return; }
                if (!gameState.isTutorial && points > 5) { addLog(`Points ${points} > 5. Cannot knock.`); return; }
                processRoundEnd(gameState.players, 0);
            };

            const processRoundEnd = React.useCallback((currentPlayers, knockerIdx) => {
                if (!gameState) return;
                const prevScores = currentPlayers.map(p => p.score);
                const updated = applyFinalScores(currentPlayers, knockerIdx, gameState.jokerDeclarations);
                const roundPts = updated.map((p, i) => p.score - prevScores[i]);
                
                setGameState(prev => ({
                    ...prev,
                    players: updated,
                    turnPhase: 'ROUND_OVER',
                    logs: [`${currentPlayers[knockerIdx].name} knocked!`, ...prev.logs]
                }));
                setRoundSummary({ roundPoints: roundPts, previousScores: prevScores, updatedPlayers: updated, knockerIndex: knockerIdx });
            }, [gameState]);

            const startNextRound = () => {
                if (!gameState || !roundSummary) return;
                if (gameState.isTutorial) { setGameState(null); setGameStarted(false); return; }
                
                const { updatedPlayers } = roundSummary;
                if (updatedPlayers.some(p => p.score >= MAX_SCORE)) {
                    const winner = updatedPlayers.reduce((p, c) => p.score < c.score ? p : c);
                    setGameState({ ...gameState, winner, turnPhase: 'GAME_OVER' });
                    setRoundSummary(null);
                } else {
                    const deck = createDeck(updatedPlayers.length);
                    updatedPlayers.forEach(p => { p.hand = deck.splice(0, 7).sort((a,b)=>a.sortValue - b.sortValue); p.melds = []; });
                    const initialSequences = {
                        [Suit.HEARTS]: { suit: Suit.HEARTS, low: 7, high: 7, hasSeven: false },
                        [Suit.DIAMONDS]: { suit: Suit.DIAMONDS, low: 7, high: 7, hasSeven: false },
                        [Suit.CLUBS]: { suit: Suit.CLUBS, low: 7, high: 7, hasSeven: false },
                        [Suit.SPADES]: { suit: Suit.SPADES, low: 7, high: 7, hasSeven: false },
                        [Suit.JOKER]: { suit: Suit.JOKER, low: 0, high: 0, hasSeven: false }
                    };
                    setGameState({
                        players: updatedPlayers,
                        currentPlayerIndex: (gameState.round) % updatedPlayers.length,
                        deck, discardPile: [], boardSequences: initialSequences,
                        turnPhase: 'ACTION', round: gameState.round + 1, winner: null,
                        logs: [`Round ${gameState.round + 1}`], pendingPong: null, jokerDeclarations: []
                    });
                    setRoundSummary(null);
                }
            };

            const doPong = () => {
                if (!gameState || !gameState.pendingPong) return;
                const human = gameState.players[0];
                const discard = gameState.pendingPong.card;
                const naturalMatches = human.hand.filter(c => c.rank === discard.rank && !c.isJoker);
                const jokers = human.hand.filter(c => c.isJoker);
                
                let cardsToUse = naturalMatches.length >= 2 ? naturalMatches.slice(0, 2) : [naturalMatches[0], jokers[0]];
                if (naturalMatches.length === 0) cardsToUse = jokers.slice(0, 2);

                if (cardsToUse.some(c => c.isJoker)) {
                    setMeldDeclarations({});
                    setPendingMeldAction({ type: 'PONG', cards: [...cardsToUse, discard], naturalRank: discard.rank, jokersCount: cardsToUse.filter(c=>c.isJoker).length });
                    setShowPongModal(false);
                    return;
                }
                
                const newHand = human.hand.filter(c => !cardsToUse.includes(c));
                const nextStep = gameState.isTutorial ? (gameState.tutorialStep || 0) + 1 : gameState.tutorialStep;
                setGameState({
                    ...gameState,
                    players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand, melds: [...p.melds, [...cardsToUse, discard]] } : p),
                    discardPile: gameState.discardPile.slice(1),
                    currentPlayerIndex: 0, turnPhase: 'ACTION', pendingPong: null,
                    logs: ["You Ponged!", ...gameState.logs], tutorialStep: nextStep
                });
                setShowPongModal(false);
            };

            React.useEffect(() => {
                if (showPongModal && pongTimer > 0) {
                    const t = setTimeout(() => setPongTimer(v => v-1), 1000);
                    return () => clearTimeout(t);
                }
                if (showPongModal && pongTimer === 0) setShowPongModal(false);
            }, [showPongModal, pongTimer]);

            React.useEffect(() => {
                if (showPongModal) setPongTimer(10);
            }, [showPongModal]);

            // --- Pong Watcher ---
            React.useEffect(() => {
                if (!gameState?.pendingPong) return;
                if (gameState.isTutorial && gameState.pendingPong.discarderIndex !== 0) { setShowPongModal(true); return; }
                
                if (gameState.pendingPong.discarderIndex !== 0) {
                    const h = gameState.players[0];
                    const r = gameState.pendingPong.card.rank;
                    const match = h.hand.filter(c => c.rank === r && !c.isJoker).length + h.hand.filter(c => c.isJoker).length;
                    if (match >= 2) setShowPongModal(true);
                    else setGameState(prev => ({...prev, pendingPong: null}));
                } else {
                    setGameState(prev => ({...prev, pendingPong: null}));
                }
            }, [gameState?.pendingPong]);

            // --- BOT AI ---
            React.useEffect(() => {
                if (!gameState || gameState.turnPhase !== 'ACTION' || gameState.currentPlayerIndex === 0 || gameState.pendingPong || !gameStarted) return;
                
                const runBot = async () => {
                    await new Promise(r => setTimeout(r, 1000));
                    if (gameState.isTutorial) {
                         const bot = gameState.players[1];
                         let deck = [...gameState.deck];
                         let newHand = [...bot.hand];
                         if (deck.length > 0) newHand.push(deck.shift());
                         
                         const discard = newHand.find(c => c.rank === Rank.TWO && c.suit === Suit.CLUBS) || newHand[0];
                         newHand = newHand.filter(c => c.id !== discard.id);
                         setGameState(prev => ({
                             ...prev, deck, players: prev.players.map((p,i) => i === 1 ? {...p, hand: newHand} : p),
                             discardPile: [discard, ...prev.discardPile],
                             pendingPong: { card: discard, discarderIndex: 1 },
                             logs: ["Bot discarded Club 2", ...prev.logs],
                             tutorialStep: (prev.tutorialStep || 0) + 1
                         }));
                         return;
                    }

                    // Standard AI Logic (Simplified for single file)
                    const botIdx = gameState.currentPlayerIndex;
                    const bot = gameState.players[botIdx];
                    let newHand = [...bot.hand], newMelds = [...bot.melds], newSeqs = {...gameState.boardSequences}, newDecls = [...gameState.jokerDeclarations];
                    let played = true;

                    while(played) {
                        played = false;
                        // Melds
                        const counts = {};
                        newHand.filter(c=>!c.isJoker).forEach(c => { counts[c.rank] = (counts[c.rank] || []).concat(c); });
                        for(const r in counts) {
                            if(counts[r].length >= 3) {
                                const m = counts[r].slice(0,3);
                                newMelds.push(m);
                                newHand = newHand.filter(c => !m.includes(c));
                                played = true; break;
                            }
                        }
                        if(played) continue;

                        // Play
                        for(let i=0; i<newHand.length; i++) {
                            const c = newHand[i];
                            if(!c.isJoker) {
                                if(c.rank === Rank.SEVEN && !newSeqs[c.suit].hasSeven) {
                                    newSeqs[c.suit].hasSeven = true; newHand.splice(i,1); played = true; break;
                                }
                                if(canPlayOnBoard(c, newSeqs)) {
                                    const s = newSeqs[c.suit];
                                    if(c.sortValue === s.high+1) s.high = c.sortValue;
                                    if(c.sortValue === s.low-1) s.low = c.sortValue;
                                    newHand.splice(i,1); played = true; break;
                                }
                            } else {
                                // Joker AI
                                const validSuits = SUITS.filter(s => s !== Suit.JOKER && newSeqs[s].hasSeven);
                                for (const s of validSuits) {
                                    const seq = newSeqs[s];
                                    let tR = null;
                                    if (seq.high < 13) tR = RANKS[seq.high];
                                    else if (seq.low > 1) tR = RANKS[seq.low-2];
                                    
                                    if(tR && tR !== Rank.SEVEN) {
                                        if(getSortValue(tR) > seq.high) seq.high = getSortValue(tR); else seq.low = getSortValue(tR);
                                        newDecls.push({ cardId: c.id, representedSuit: s, representedRank: tR });
                                        newHand.splice(i,1); played = true; break;
                                    }
                                }
                                if(played) break;
                            }
                        }
                    }

                    if(calculateHandPoints(newHand) <= 5) {
                         processRoundEnd(gameState.players.map((p,i)=>i===botIdx ? {...p, hand: newHand, melds: newMelds} : p), botIdx);
                         return;
                    }

                    let deck = [...gameState.deck];
                    if(deck.length > 0) newHand.push(deck.shift());
                    newHand.sort((a,b)=>a.sortValue - b.sortValue);
                    
                    // Smart Discard: Avoid Jokers unless it's the only option
                    const nonJokers = newHand.filter(c => !c.isJoker);
                    const candidates = nonJokers.length > 0 ? nonJokers : newHand;
                    const discIdxInCandidates = candidates.reduce((iMax, x, i, arr) => x.value > arr[iMax].value ? i : iMax, 0);
                    const discCard = candidates[discIdxInCandidates];
                    const realDiscIdx = newHand.indexOf(discCard);
                    newHand.splice(realDiscIdx, 1);

                    setGameState(prev => ({
                        ...prev,
                        players: prev.players.map((p,i)=>i===botIdx ? {...p, hand: newHand, melds: newMelds} : p),
                        boardSequences: newSeqs, jokerDeclarations: newDecls, deck,
                        discardPile: [discCard, ...prev.discardPile],
                        currentPlayerIndex: (botIdx + 1) % prev.players.length,
                        pendingPong: { card: discCard, discarderIndex: botIdx },
                        logs: [`${bot.name} discarded ${discCard.rank}`, ...prev.logs]
                    }));
                };
                runBot();
            }, [gameState?.currentPlayerIndex, gameState?.turnPhase, gameState?.pendingPong]);

            if (!gameStarted) {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center p-4 text-center">
                        <h1 className="text-6xl font-bold mb-8 text-yellow-400 drop-shadow-lg">Sevens & Melds</h1>
                        <div className="bg-green-900 p-8 rounded-xl shadow-2xl border border-green-700 w-full max-w-md">
                            <label className="block mb-2 font-bold text-green-300">Players</label>
                            <div className="flex justify-center gap-2 mb-6">
                                {[2,3,4,5,6].map(n => (
                                    <button key={n} onClick={() => setPlayerCount(n)} className={`w-12 h-12 rounded-full font-bold text-xl transition-all ${playerCount===n ? 'bg-yellow-400 text-black scale-110' : 'bg-green-700 text-white hover:bg-green-600'}`}>{n}</button>
                                ))}
                            </div>
                            
                            <button onClick={() => setShowKeyInput(!showKeyInput)} className="text-xs text-green-400 underline mb-2">
                                {showKeyInput ? 'Hide API Key' : 'Configure API Key (For Hints)'}
                            </button>
                            {showKeyInput && (
                                <input 
                                    type="text" 
                                    placeholder="Enter Google Gemini API Key" 
                                    value={apiKey} 
                                    onChange={(e) => setApiKey(e.target.value)} 
                                    className="w-full mb-4 p-2 rounded text-black text-sm"
                                />
                            )}

                            <button onClick={startGame} className="w-full py-4 bg-yellow-500 hover:bg-yellow-400 text-black font-bold rounded-lg text-2xl shadow-lg mb-4 transform hover:scale-105 transition-transform">
                                New Game
                            </button>
                            <button onClick={startTutorial} className="w-full py-4 bg-blue-500 hover:bg-blue-400 text-white font-bold rounded-lg text-2xl shadow-lg transform hover:scale-105 transition-transform">
                                Tutorial
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full w-full overflow-hidden">
                    {/* TOP BAR: Info & Logs */}
                    <div className="flex-none h-16 bg-black/40 flex items-center justify-between px-4 z-50 shadow-md backdrop-blur-sm">
                        <div className="flex items-center gap-4 text-sm sm:text-base">
                            <span className="font-bold text-yellow-400">Round {gameState.round}</span>
                            <span className="hidden sm:inline">|</span>
                            <span className="font-mono bg-black/30 px-2 py-1 rounded hidden sm:inline">Deck: {gameState.deck.length}</span>
                        </div>
                        
                        {/* Scrollable Logs - Horizontal on mobile, text overflow handling */}
                        <div className="flex-1 mx-4 h-full flex items-center overflow-hidden">
                            <div className="text-xs sm:text-sm text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis w-full text-center">
                                {gameState.logs[0] || "..."}
                            </div>
                        </div>

                        <div className="flex items-center gap-2">
                             <button onClick={() => getAIHint(gameState)} disabled={isLoadingHint || !apiKey} className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-500 text-xs sm:text-sm font-bold disabled:opacity-50">
                                {isLoadingHint ? 'Thinking...' : 'AI Hint'}
                             </button>
                             <div className="text-right">
                                <div className="text-xs text-gray-400">You</div>
                                <div className="font-bold text-yellow-400">{calculateHandPoints(gameState.players[0].hand)} pts</div>
                            </div>
                        </div>
                    </div>

                    {/* MAIN GAME AREA: Scrollable Table */}
                    <div className="flex-1 overflow-y-auto overflow-x-hidden relative w-full bg-green-800 flex flex-col pb-4">
                        
                        {/* Tutorial Overlay */}
                        {gameState.isTutorial && TUTORIAL_STEPS[gameState.tutorialStep] && (
                            <div className="mx-4 mt-4 bg-blue-600/90 text-white p-4 rounded-xl shadow-lg border-2 border-blue-400 animate-fade-in relative z-40 max-w-3xl lg:mx-auto">
                                <h3 className="font-bold text-lg mb-1">🎓 {TUTORIAL_STEPS[gameState.tutorialStep].title}</h3>
                                <p>{TUTORIAL_STEPS[gameState.tutorialStep].text}</p>
                            </div>
                        )}

                        {/* Hint Overlay */}
                        {aiHint && (
                             <div className="mx-4 mt-4 bg-purple-900/90 text-white p-4 rounded-xl shadow-lg border-2 border-purple-500 animate-fade-in relative z-40 max-w-3xl lg:mx-auto">
                                <div className="flex justify-between items-start">
                                    <h3 className="font-bold text-lg mb-1">🤖 AI Strategy</h3>
                                    <button onClick={() => setAiHint(null)} className="text-gray-400 hover:text-white">&times;</button>
                                </div>
                                <p>{aiHint}</p>
                            </div>
                        )}

                        {/* Opponents (Simplified Visualization) */}
                        <div className="flex justify-center gap-4 py-4 flex-wrap px-2">
                            {gameState.players.filter(p => !p.isHuman).map(bot => (
                                <div key={bot.id} className={`flex flex-col items-center p-2 rounded-lg ${gameState.currentPlayerIndex === bot.id ? 'bg-yellow-500/20 border-yellow-400 border' : 'bg-black/20'}`}>
                                    <div className="w-8 h-8 sm:w-10 sm:h-10 rounded-full bg-gray-700 flex items-center justify-center text-sm font-bold border-2 border-gray-500">
                                        Bot
                                    </div>
                                    <div className="text-xs mt-1 text-center">
                                        <div>{bot.hand.length} cards</div>
                                        <div>{bot.score} pts</div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Central Board Sequences */}
                        <div className="mb-4">
                            <Board sequences={gameState.boardSequences} />
                        </div>

                        {/* Deck and Discard Row */}
                        <div className="flex justify-center items-center gap-8 sm:gap-16 min-h-[160px] pb-4">
                            {/* Deck */}
                            <div className="relative group cursor-pointer" onClick={drawCard}>
                                <div className={`${CARD_WIDTH} ${CARD_HEIGHT} bg-blue-800 rounded-xl border-2 border-blue-400 shadow-xl flex items-center justify-center pattern-grid transform group-hover:-translate-y-2 transition-transform`}>
                                    <span className="text-4xl text-white/20 font-bold">DECK</span>
                                </div>
                                <span className="absolute -bottom-6 left-1/2 -translate-x-1/2 text-sm font-bold text-white/70">DRAW</span>
                            </div>

                            {/* Discard Pile */}
                            <div className="relative">
                                {gameState.discardPile.length === 0 ? (
                                    <div className={`${CARD_WIDTH} ${CARD_HEIGHT} border-4 border-dashed border-white/20 rounded-xl flex items-center justify-center`}>
                                        <span className="text-white/20 font-bold">DISCARD</span>
                                    </div>
                                ) : (
                                    <div className="relative">
                                        {gameState.discardPile.slice(0, 3).map((card, i) => (
                                            <div key={card.id} className={`absolute top-0 left-0 ${i > 0 ? 'ml-1 mt-1' : ''}`} style={{ transform: `translate(${i*2}px, ${i*2}px)` }}>
                                                <Card card={card} className="opacity-60" />
                                            </div>
                                        ))}
                                        <div className="relative z-10" style={{ transform: `translate(${Math.min(gameState.discardPile.length, 3)*2}px, ${Math.min(gameState.discardPile.length, 3)*2}px)` }}>
                                            <Card card={gameState.discardPile[0]} />
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* PLAYER HAND AREA: Fixed Bottom */}
                    <div className="flex-none h-48 sm:h-56 bg-gradient-to-t from-black via-black/80 to-transparent relative z-40 flex flex-col justify-end pb-4 px-2">
                         {/* Action Buttons Floating above Hand */}
                        <div className="absolute top-0 left-0 w-full -translate-y-full flex justify-center pb-2 gap-4 pointer-events-none">
                            <div className="pointer-events-auto flex gap-4">
                                {gameState.turnPhase === 'ACTION' && (
                                    <button 
                                        onClick={playSelectedCards}
                                        disabled={selectedCards.length === 0}
                                        className={`px-6 py-3 rounded-full font-bold shadow-lg transition-all ${selectedCards.length > 0 ? 'bg-green-500 hover:bg-green-400 text-white transform hover:scale-110' : 'bg-gray-600 text-gray-400'}`}
                                    >
                                        {selectedCards.length > 1 ? 'Meld / Play' : 'Play Selected'}
                                    </button>
                                )}
                                {gameState.turnPhase === 'DISCARD' && (
                                    <button 
                                        onClick={discardCard}
                                        disabled={selectedCards.length !== 1}
                                        className={`px-6 py-3 rounded-full font-bold shadow-lg transition-all ${selectedCards.length === 1 ? 'bg-red-500 hover:bg-red-400 text-white transform hover:scale-110' : 'bg-gray-600 text-gray-400'}`}
                                    >
                                        Discard Selected
                                    </button>
                                )}
                                <button 
                                    onClick={handleKnock}
                                    className="px-6 py-3 rounded-full font-bold shadow-lg bg-yellow-600 hover:bg-yellow-500 text-white transition-all"
                                >
                                    Knock
                                </button>
                            </div>
                        </div>

                        {/* Scrollable Hand Container */}
                        <div className="flex items-end justify-center overflow-x-auto px-4 pb-2 w-full gap-[-2rem]">
                            <div className="flex items-end space-x-[-3rem] sm:space-x-[-4rem] min-w-min px-8">
                                {gameState.players[0].hand.map((card, index) => (
                                    <div key={card.id} className="transform transition-transform hover:z-20 hover:-translate-y-4" style={{ zIndex: index }}>
                                        <Card 
                                            card={card} 
                                            onClick={() => handleCardClick(card)}
                                            isSelected={selectedCards.includes(card.id)}
                                            isPlayable={gameState.currentPlayerIndex === 0}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Modals */}
                    {showPongModal && (
                        <Modal title={`PONG Opportunity! (${pongTimer}s)`}>
                            <div className="text-center">
                                <p className="mb-4">You can Pong the <strong>{gameState.pendingPong.card.rank} {gameState.pendingPong.card.suit}</strong>!</p>
                                <div className="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                                    <div className="bg-blue-600 h-2.5 rounded-full transition-all duration-1000" style={{ width: `${(pongTimer/10)*100}%` }}></div>
                                </div>
                                <div className="flex justify-center gap-4">
                                    <button onClick={doPong} className="px-6 py-3 bg-green-500 hover:bg-green-400 rounded-lg font-bold text-white shadow-lg">
                                        PONG!
                                    </button>
                                    <button onClick={() => setShowPongModal(false)} className="px-6 py-3 bg-gray-500 hover:bg-gray-400 rounded-lg font-bold text-white">
                                        Pass
                                    </button>
                                </div>
                            </div>
                        </Modal>
                    )}

                    {showSingleJokerModal && (
                        <Modal title="Declare Joker" onClose={() => { setShowSingleJokerModal(false); setPendingSingleJokerMove(null); }}>
                             <div className="grid grid-cols-2 gap-4">
                                 {SUITS.filter(s => s !== Suit.JOKER && gameState.boardSequences[s].hasSeven).map(suit => {
                                     const seq = gameState.boardSequences[suit];
                                     const opts = [];
                                     if (seq.high < 13) opts.push({ type: 'HIGH', val: seq.high + 1, label: `${RANKS[seq.high]} (High)` });
                                     if (seq.low > 1) opts.push({ type: 'LOW', val: seq.low - 1, label: `${RANKS[seq.low-2]} (Low)` });

                                     return (
                                         <div key={suit} className="border p-2 rounded">
                                             <div className="text-2xl text-center mb-2">{suit}</div>
                                             <div className="flex flex-col gap-2">
                                                 {opts.map(opt => (
                                                     <button 
                                                         key={opt.val}
                                                         onClick={() => confirmSingleJokerMove(suit, RANKS[opt.val-1])}
                                                         className="bg-blue-100 hover:bg-blue-200 py-2 rounded text-sm"
                                                     >
                                                         {opt.label}
                                                     </button>
                                                 ))}
                                                 {opts.length === 0 && <span className="text-xs text-center text-gray-400">Full</span>}
                                             </div>
                                         </div>
                                     );
                                 })}
                             </div>
                        </Modal>
                    )}

                    {pendingMeldAction && pendingMeldAction.jokersCount > 0 && (
                        <Modal title="Declare Jokers" onClose={() => setPendingMeldAction(null)}>
                            <div className="p-2 space-y-4">
                                <p className="text-center text-gray-600">
                                    {pendingMeldAction.naturalRank 
                                        ? `Melding Rank: ${pendingMeldAction.naturalRank}. Select suits for Jokers:` 
                                        : `Melding 3 Jokers. Select Rank and Suits:`}
                                </p>

                                {/* Rank Selector for Pure Joker Meld */}
                                {!pendingMeldAction.naturalRank && (
                                    <div className="flex flex-col">
                                        <label className="text-sm font-bold text-gray-700">Select Rank</label>
                                        <select 
                                            className="border p-2 rounded"
                                            value={meldDeclarations['rank'] || ''}
                                            onChange={(e) => setMeldDeclarations({...meldDeclarations, rank: e.target.value})}
                                        >
                                            <option value="">-- Choose Rank --</option>
                                            {RANKS.filter(r => r !== Rank.SEVEN && r !== Rank.JOKER).map(r => (
                                                <option key={r} value={r}>{r}</option>
                                            ))}
                                        </select>
                                    </div>
                                )}

                                {/* Suit Selectors for each Joker */}
                                {pendingMeldAction.cards.filter(c => c.isJoker).map((joker, idx) => (
                                    <div key={joker.id} className="flex flex-col border-t pt-2">
                                        <label className="text-sm font-bold text-gray-700">Joker {idx + 1}</label>
                                        <select 
                                            className="border p-2 rounded"
                                            value={meldDeclarations[joker.id]?.suit || ''}
                                            onChange={(e) => {
                                                setMeldDeclarations({
                                                    ...meldDeclarations,
                                                    [joker.id]: { ...meldDeclarations[joker.id], suit: e.target.value }
                                                });
                                            }}
                                        >
                                            <option value="">-- Choose Suit --</option>
                                            {SUITS.filter(s => s !== Suit.JOKER).map(s => (
                                                <option key={s} value={s}>{s}</option>
                                            ))}
                                        </select>
                                    </div>
                                ))}

                                <button 
                                    onClick={confirmMeldWithJokers}
                                    className="w-full py-3 bg-green-600 hover:bg-green-500 text-white rounded font-bold shadow-lg"
                                >
                                    Confirm Declaration
                                </button>
                            </div>
                        </Modal>
                    )}

                    {roundSummary && (
                        <Modal title="Round Over">
                            <div className="space-y-4">
                                <div className="bg-yellow-100 p-4 rounded text-center">
                                    <h3 className="text-xl font-bold text-yellow-800 mb-2">
                                        {roundSummary.updatedPlayers[roundSummary.knockerIndex].name} Knocked!
                                    </h3>
                                </div>
                                <table className="w-full text-left border-collapse">
                                    <thead>
                                        <tr className="border-b">
                                            <th className="p-2">Player</th>
                                            <th className="p-2">Hand Pts</th>
                                            <th className="p-2">Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {roundSummary.updatedPlayers.map((p, i) => (
                                            <tr key={i} className={i === roundSummary.knockerIndex ? "bg-yellow-50" : ""}>
                                                <td className="p-2 font-bold">{p.name} {p.score >= MAX_SCORE && "💀"}</td>
                                                <td className="p-2 text-red-600">+{roundSummary.roundPoints[i]}</td>
                                                <td className="p-2">{p.score}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                                <button onClick={startNextRound} className="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded shadow-lg">
                                    {roundSummary.updatedPlayers.some(p => p.score >= MAX_SCORE) ? "View Game Results" : "Next Round"}
                                </button>
                            </div>
                        </Modal>
                    )}
                    
                    {gameState.turnPhase === 'GAME_OVER' && (
                        <Modal title="Game Over">
                            <div className="text-center">
                                <div className="text-6xl mb-4">🏆</div>
                                <h2 className="text-3xl font-bold text-green-600 mb-2">{gameState.winner.name} Wins!</h2>
                                <p className="mb-6 text-gray-600">Lowest score: {gameState.winner.score}</p>
                                <button onClick={() => { setGameState(null); setGameStarted(false); }} className="px-8 py-3 bg-yellow-500 text-black font-bold rounded shadow-lg">
                                    Main Menu
                                </button>
                            </div>
                        </Modal>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>